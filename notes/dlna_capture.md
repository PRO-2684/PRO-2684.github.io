---
title: DLNA æ•è·
tags: [Technical, Latest, Rust]
keywords: [DLNA, capture, æ•è·, Windows, Media, DMR]
description: æ­¤æ–‡ä»‹ç»äº†å¦‚ä½•åœ¨ Windows ä¸‹åˆ©ç”¨ç³»ç»Ÿè‡ªå¸¦çš„ Windows Media Player æ•è· DLNA æŠ•å±çš„åª’ä½“æµç½‘å€ï¼ŒDLNA çš„åŸºæœ¬åŸç†ï¼Œä»¥åŠå¦‚ä½•ç¼–å†™ä¸€ä¸ªç¨‹åºå®ç°æ•è·çš„è‡ªåŠ¨åŒ–
---

# DLNA æ•è·

## ğŸ’¬ å‰è¨€

ä¼—æ‰€å‘¨çŸ¥ï¼Œä¼—å¤šæµåª’ä½“å¹³å°ä¸å†æä¾›ç½‘é¡µç«¯çš„æœåŠ¡ï¼Œåªèƒ½åœ¨ APP å†…çœ‹è§†é¢‘ï¼Œè€Œè¿™å°±åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¦¨ç¢äº†æˆ‘ä»¬æŠ“åŒ…ã€è·å–ç½‘å€ã€ä¸‹è½½è§†é¢‘çš„å·¥ä½œæµã€‚ä¸ºäº†è®©ç”¨æˆ·èƒ½å¤Ÿåœ¨æ™ºèƒ½ç”µè§†ä¸Šçœ‹è§†é¢‘ï¼Œè¿™äº›å¹³å°åˆå¾€å¾€ä¼šæä¾›ä¸€ä¸ªæŠ•å±åˆ°ç”µè§†çš„é€‰é¡¹ã€‚

è™½ç„¶å¤§å®¶éƒ½çº¦å®šä¿—æˆåœ°è¯´æ˜¯â€œæŠ•å±â€ï¼Œä½†å®é™…ä¸Šè¿™ä¸ªç§°å‘¼æ˜¯æœ‰æ­§ä¹‰çš„ï¼Œæ—¢å¯ä»¥æŒ‡â€œå°†å±å¹•é•œåƒåˆ°å¦ä¸€ä¸ªè®¾å¤‡â€ï¼Œä¹Ÿå¯ä»¥æŒ‡â€œå°†æŸåª’ä½“æµæŠ•é€åˆ°å¦ä¸€ä¸ªè®¾å¤‡â€ã€‚å‰è€…éœ€è¦åœ¨å±€åŸŸç½‘å†…å®æ—¶ä¼ è¾“ç”»é¢ï¼Œè€Œåè€…å¾€å¾€åªéœ€è¦å°†ä¸€ä¸ªç½‘å€ä¼ è¾“ç»™ç›®æ ‡è®¾å¤‡ã€‚è¿™é‡Œæˆ‘ä»¬ä»…é’ˆå¯¹ç¬¬äºŒç§æƒ…å†µå±•å¼€è®¨è®ºã€‚

## ğŸªŸ Windows Media Player

æ—¢ç„¶ç”µè§†ä¸Šèƒ½å¤Ÿæ’­æ”¾æŠ•å±çš„åª’ä½“æµï¼Œé‚£ä¹ˆç†è®ºä¸Šæˆ‘ä»¬å¯ä»¥ç”¨ç”µè„‘æ¨¡æ‹Ÿæˆä¸€ä¸ªç”µè§†ï¼Œè®©ç”µè„‘æ¥æ”¶åª’ä½“æµçš„ç½‘å€ã€‚å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿå¾—åˆ°è¿™ä¸ªç½‘å€ï¼Œé‚£ä¹ˆä¸‹è½½åª’ä½“ä¹Ÿå°±ä¸åœ¨è¯ä¸‹äº†ã€‚ç»è¿‡ä¸€ç•ªæœç´¢ï¼Œæˆ‘å‘ç° Windows Media Player å¯ä»¥æ¥å—åª’ä½“æµæ¨é€ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬å°è¯•åˆ©ç”¨å®ƒæ¥è·å–åª’ä½“æµç½‘å€ã€‚

### å¯ç”¨åª’ä½“æµ

é¦–å…ˆæ‰“å¼€æ§åˆ¶é¢æ¿ï¼Œè¿›å…¥â€œç½‘ç»œå…±äº«ä¸­å¿ƒâ€ï¼Œç‚¹å‡»å·¦ä¾§æ çš„â€œåª’ä½“æµå¼å¤„ç†é€‰é¡¹â€ï¼š

![åª’ä½“æµå¼å¤„ç†é€‰é¡¹](/attachments/control_media_stream.jpg)

ç„¶åå•å‡»â€œå¯ç”¨åª’ä½“æµâ€æŒ‰é’®ï¼š

![å¯ç”¨åª’ä½“æµ](/attachments/control_enable_media_stream.png)

<details><summary>â€œåª’ä½“æµæœªå¯ç”¨â€ï¼Ÿ</summary>

è‹¥å‡ºç°ä¸‹å›¾æ‰€ç¤ºâ€œåª’ä½“æµæœªå¯ç”¨â€çš„æç¤ºï¼š

![åª’ä½“æµæœªå¯ç”¨](/attachments/control_media_stream_disabled.png)

é‚£ä¹ˆç‚¹å‡»ä¸‹æ–¹çš„â€œWindows æœåŠ¡ç®¡ç†å·¥å…·â€ï¼Œç„¶åæ‰¾åˆ°â€œWindows Media Player Network Sharing Serviceâ€æœåŠ¡ï¼š

![â€œWindows Media Player Network Sharing Serviceâ€æœåŠ¡](/attachments/service_wmp.png)

å³é”®ï¼Œé€‰æ‹©â€œå±æ€§â€ï¼Œå°†å…¶å¯åŠ¨ç±»å‹è®¾ç½®ä¸ºâ€œè‡ªåŠ¨â€æˆ–è€…â€œè‡ªåŠ¨ï¼ˆå»¶è¿Ÿå¯åŠ¨ï¼‰â€ï¼Œç‚¹å‡»â€œåº”ç”¨â€åå†æ¬¡ç‚¹å‡»â€œå¯åŠ¨â€ï¼š

![â€œWindows Media Player Network Sharing Serviceâ€æœåŠ¡å±æ€§è®¾ç½®](/attachments/service_wmp_prop.png)

è‹¥æç¤ºä¸‹è¿°ä¿¡æ¯ï¼š

```text
Windows æ— æ³•å¯ç”¨ Windows Media Player Network Sharing Service æœåŠ¡ (ä½äº æœ¬åœ°è®¡ç®—æœº ä¸Š)
é”™è¯¯ 1068: ä¾èµ–æœåŠ¡æˆ–ç»„æ— æ³•å¯åŠ¨ã€‚
```

åˆ™å…ˆç”¨åŒæ ·æ–¹æ³•å¯åŠ¨â€œä¾å­˜å…³ç³»â€ä¸­çš„äº”ä¸ªæœåŠ¡ ([ref](https://answers.microsoft.com/zh-hans/windows/forum/all/windows%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8windows/2a007912-941f-4470-9e7e-9b0627123edc))ï¼š

![ä¾å­˜å…³ç³»](/attachments/service_dependencies.png)

- Windows Search
- Background Tasks Infrastructure Service
- Remote Procedure Call (RPC)
- DCOM Server Process Launcher
- RPC Endpoint Mapper

å¯åŠ¨æˆåŠŸåå³å¯å…³é—­â€œæœåŠ¡â€çª—å£ï¼Œç„¶å **é‡æ–°è¿›å…¥** æ§åˆ¶é¢æ¿çš„â€œåª’ä½“æµé€‰é¡¹â€ã€‚

</details>

éšåï¼Œåœ¨æ‰€æœ‰ç½‘ç»œä¸­å…è®¸è®¿é—®å…±äº«åª’ä½“ï¼š

![å…è®¸è®¿é—®å…±äº«åª’ä½“](/attachments/control_allow_accessing_media.png)

å®Œæˆä¸Šè¿°æ­¥éª¤åå³å¯å…³é—­æ§åˆ¶é¢æ¿ã€‚

### å…è®¸è¿œç¨‹æ§åˆ¶æˆ‘çš„æ’­æ”¾å™¨

æ‰“å¼€ Windows Media Player (æ‰¾ä¸åˆ°å¯ä»¥æœç´¢) è½¯ä»¶ï¼Œåœ¨â€œåª’ä½“æµâ€é€‰é¡¹ä¸­å‹¾é€‰â€œå…è®¸è¿œç¨‹æ§åˆ¶æˆ‘çš„æ’­æ”¾å™¨â€ï¼š

![å…è®¸è¿œç¨‹æ§åˆ¶æˆ‘çš„æ’­æ”¾å™¨](/attachments/wmp_legacy_allow_remote_control.png)

æ³¨æ„ï¼Œè¿™ä¸€æ­¥ä¹‹åä¸èƒ½å…³é—­ Windows Media Playerï¼Œå¦åˆ™ä¼šå¯¼è‡´åç»­æ‰¾ä¸åˆ°è®¾å¤‡ã€‚

### å¼€å§‹æŠ•å±

å°†æ‰‹æœºæˆ–å…¶ä»–è®¾å¤‡è¿æ¥åˆ°åŒä¸€å±€åŸŸç½‘ï¼Œæ‰“å¼€ä¸€ä¸ªæ”¯æŒ DLNA çš„ APP (å¦‚å“”å“©å“”å“©)ï¼Œå¹¶æ‰“å¼€ä»»æ„è§†é¢‘ (ä¾‹å¦‚ [BV1GJ411x7h7](https://b23.tv/BV1GJ411x7h7))ï¼Œåœ¨æ’­æ”¾ç•Œé¢ç‚¹å‡»æŠ•å±æŒ‰é’®ï¼Œé€‰æ‹©ä½ çš„ç”µè„‘ï¼š

![å“”å“©å“”å“©æŠ•å±](/attachments/bilibili_screencast.jpg)

å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼ŒWindows Media Player å°±ä¼šå¼€å§‹æ’­æ”¾æ­¤è§†é¢‘ï¼š

![Windows Media Player æ’­æ”¾](/attachments/wmp_legacy_playing.png)

### æŸ¥çœ‹ç½‘å€

å³é”®ç”»é¢ï¼Œç‚¹å‡»â€œæ˜¾ç¤ºæ’­æ”¾åˆ—è¡¨â€ï¼š

![æ˜¾ç¤ºæ’­æ”¾åˆ—è¡¨](/attachments/wmp_legacy_show_playlist.png)

éšååœ¨æ’­æ”¾åˆ—è¡¨ä¸­æ‰¾åˆ°åˆšæ‰æŠ•å±çš„è§†é¢‘ï¼Œå³é”®ç‚¹å‡»ï¼Œé€‰æ‹©â€œå±æ€§â€ï¼š

![æ’­æ”¾åˆ—è¡¨å±æ€§](/attachments/wmp_legacy_playlist_properties.png)

åœ¨å¼¹å‡ºçš„å±æ€§çª—å£ä¸­çš„â€œæ–‡ä»¶â€é€‰é¡¹å¡ä¸­å³å¯çœ‹åˆ°è§†é¢‘çš„ URLï¼Œä½¿ç”¨é¼ æ ‡ä»å¤´åˆ°å°¾é€‰ä¸­åå³å¯å¤åˆ¶ï¼š

![æ’­æ”¾åˆ—è¡¨å±æ€§ URL](/attachments/wmp_legacy_playlist_url.png)

éšåå¯ä»¥å°†æ­¤ URL ç²˜è´´åˆ°æµè§ˆå™¨æˆ–ä¸‹è½½å·¥å…·ä¸­è¿›è¡Œä¸‹è½½ã€‚

## DLNA

æ˜¾ç„¶ï¼Œä¸Šé¢çš„æ–¹æ³•è¿˜æ˜¯å¤ªåƒæ“ä½œäº†ï¼Œé‚£ä¹ˆæœ‰æ²¡æœ‰æ›´è‡ªåŠ¨åŒ–çš„æ–¹å¼å‘¢ï¼Ÿç­”æ¡ˆæ˜¯æœ‰çš„ï¼Œä½†éœ€è¦ç¼–å†™ä¸€ä¸ªç¨‹åºæ‰®æ¼” DLNA DMR (Digital Media Renderer) çš„è§’è‰²ï¼Œè‡ªåŠ¨æ¥æ”¶åª’ä½“æµå¹¶æå– URLã€‚é¦–å…ˆï¼Œæˆ‘ä»¬ç®€å•ä»‹ç»ä¸€ä¸‹ DLNA åè®®ï¼š

> **Digital Living Network Alliance**Â (**DLNA**) is a set ofÂ interoperabilityÂ standards forÂ sharingÂ homeÂ digital mediaÂ amongÂ multimediaÂ devices.

è¿™ä¸ªæ ‡å‡†ä¸»è¦åŒ…æ‹¬ä¸‹é¢äº”ä¸ªè§’è‰²ï¼š

- Digital Media Server (DMS): æ•°ä½åª’ä½“ä¼ºæœå™¨ï¼Œå­˜å‚¨å¹¶æä¾›åª’ä½“æ–‡ä»¶ã€‚
- Digital Media Renderer (DMR): æ•°ä½åª’ä½“æ¸²æŸ“å™¨ï¼Œå¯æ¥æ”¶å¹¶æ’­æ”¾ä» DMC æ¨é€è¿‡æ¥çš„åª’ä½“æ¡£æ¡ˆã€‚(æ¥æ”¶å¹¶æ‰§è¡Œ DMC å‘é€çš„æŒ‡ä»¤)
- Digital Media Controller (DMC): æ•°ä½åª’ä½“æ§åˆ¶å™¨ï¼Œä½œä¸ºé¥æ§è£…ç½®ä½¿ç”¨ï¼Œå¯å¯»æ‰¾ DMS ä¸Šçš„å¤šåª’ä½“æ¡£æ¡ˆï¼Œå¹¶æŒ‡å®šå¯æ’­æ”¾è¯¥å¤šåª’ä½“æ¡£æ¡ˆçš„ DMR è¿›è¡Œæ’­æ”¾æˆ–æ˜¯æ§åˆ¶å¤šåª’ä½“æ¡£æ¡ˆä¸Šä¸‹ä¼ åˆ° DMS çš„è£…ç½®ã€‚
- Digital Media Player (DMP): æ•°ä½åª’ä½“æ’­æ”¾å™¨ï¼Œå¯»æ‰¾å¹¶æ’­æ”¾æˆ–è¾“å‡º DMS æ‰€æä¾›çš„åª’ä½“æ–‡ä»¶ã€‚(DMPâ‰ˆDMR+DMC)
- Digital Media Printer (DMPr): æ•°ä½åª’ä½“å°è¡¨æœºï¼Œå¯ä»¥åœ¨ DLNA ç½‘è·¯æ¶æ„ä¸‹æä¾›åˆ—å°åŠŸèƒ½ã€‚

åœ¨ä½¿ç”¨å“”å“©å“”å“©è½¯ä»¶æŠ•å±è‡³ç”µè§†çš„åœºæ™¯ä¸‹ï¼Œå“”å“©å“”å“©å…¬å¸çš„æœåŠ¡å™¨å°±æ˜¯ DMSï¼Œæ‰‹æœºä¸Šçš„å“”å“©å“”å“©è½¯ä»¶å³ä¸º DMCï¼Œè€Œæ™ºèƒ½ç”µè§†å°±æ˜¯ DMRã€‚å› æ­¤ï¼Œä¸ºäº†è¾¾æˆâ€œDLNA æ•è·â€çš„ç›®çš„ï¼Œæˆ‘ä»¬éœ€è¦è§£å†³ä¸¤ä¸ªå…³é”®é—®é¢˜ï¼š

1. å‘ŠçŸ¥ DMCï¼šâ€œæˆ‘æ˜¯ DMRï¼Œæˆ‘å¯ä»¥æ¥å—åª’ä½“æµç„¶åæ¸²æŸ“â€
2. æ¥æ”¶å‘ç»™è‡ªå·±çš„æ§åˆ¶æŒ‡ä»¤ï¼Œç„¶åè¾“å‡ºæŒ‡ä»¤çš„å†…å®¹ï¼Œä»è€Œè·å¾—ç½‘å€
    - ç”±äºæˆ‘ä»¬åšçš„æ˜¯å‡ DMR (dummy DMR)ï¼Œå› æ­¤ä¸éœ€è¦å®ç°æŒ‡ä»¤çš„æ‰§è¡Œ

DMR å®é™…ä¸Šç”±ä¸¤ä¸ªæœåŠ¡å™¨æ„æˆï¼šä¸€ä¸ªæ˜¯ SSDP æœåŠ¡å™¨ï¼Œè´Ÿè´£é€šè¿‡ [SSDP åè®®](https://www.wikiwand.com/en/articles/Simple_Service_Discovery_Protocol) æ§åˆ¶è®¾å¤‡çš„å‘ç°ã€æ›´æ”¹ä¸ç¦»å¼€ï¼›ä¸€ä¸ªæ˜¯ HTTP æœåŠ¡å™¨ï¼Œè´Ÿè´£æ‰˜ç®¡å„ç§æè¿°æ–‡ä»¶ï¼Œä»¥åŠæŒ‡ä»¤çš„æ¥æ”¶å’Œç»“æœçš„è¿”å›ã€‚

### SSDP

**Simple Service Discovery Protocol**Â (**SSDP**) æ˜¯åŸºäºæ–‡æœ¬çš„åè®®ã€‚é™¤äº†å®ƒä½¿ç”¨ UDP å¤–ï¼Œå…¶å®ƒæ–¹é¢ï¼Œä¾‹å¦‚æŠ¥æ–‡ç»“æ„ï¼Œå’Œ HTTP ä¸èƒ½è¯´ååˆ†ç›¸ä¼¼ï¼Œåªèƒ½è¯´ä¸€æ¨¡ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç»å…¸çš„å¹¿æ’­æ¶ˆæ¯å¯ä»¥é•¿è¿™æ ·ï¼š

```http
NOTIFY * HTTP/1.1
Host: 239.255.255.250:1900
NT: upnp:rootdevice
NTS: ssdp:alive
Location: http://192.168.14.122:2869/upnphost/udhisapi.dll?content=uuid:04f976f9-14d8-4205-a6c4-950dad87c430
USN: uuid:04f976f9-14d8-4205-a6c4-950dad87c430::upnp:rootdevice
Cache-Control: max-age=1800
Server: Microsoft-Windows/10.0 UPnP/1.0 UPnP-Device-Host/1.0
```

é€šè¿‡ SSDP å‘ŠçŸ¥è‡ªå·±æ˜¯ DMC ä¸»è¦æœ‰ä¸¤ç§é€”å¾„ï¼š

| é€”å¾„  | HTTP Method (?)  | ä¸»/è¢«åŠ¨ | å¤‡æ³¨                          |
| --- | ---------------- | ---- | --------------------------- |
| å¹¿æ’­  | `NOTIFY`         | ä¸»åŠ¨   | å‘æ‰€æœ‰è®¾å¤‡å¹¿æ’­è‡ªå·±çš„çŠ¶æ€ (`ssdp:alive`) |
| åº”ç­”  | å¯¹ `M-SEARCH` çš„åº”ç­” | è¢«åŠ¨   | å½“æœ‰è®¾å¤‡å¯»æ‰¾ DMR æ—¶ï¼Œå‘å…¶å‘é€åº”ç­”         |

#### å¹¿æ’­

ç®€å•æ¥è¯´ï¼Œå¹¿æ’­çš„ä¸»è¦æ˜¯ä¸‹é¢è¿™äº›ä¿¡æ¯ï¼š

- é€šçŸ¥ç±»å‹ (`NT`, Notification Type)
- é€šçŸ¥å­ç±» (`NTS`, Notification Sub Type)
- å”¯ä¸€æœåŠ¡å (`USN`, Unique Service Name)
- è®¾å¤‡æè¿°æ‰€åœ¨åœ°å€ (`Location`)

DMR å®é™…ä¸Šæ³¨å†Œäº†å¤šä¸ªæœåŠ¡ï¼ŒåŒæ—¶è¿˜éœ€è¦å‘ŠçŸ¥è‡ªå·±çš„è§’è‰²ç­‰ä¿¡æ¯ï¼Œè€Œè¿™äº›éƒ½æ˜¯åˆ†å¼€å¹¿æ’­çš„ï¼Œå› æ­¤éœ€è¦å¹¿æ’­å¤šæ¬¡ã€‚å¯¹äºè®¾å¤‡æè¿°æ‰€åœ¨åœ°å€ (`Location`)ï¼Œä½ çŒœçš„æ²¡é”™ï¼Œè¿™ä¸ªæ–‡ä»¶å°±æ˜¯éœ€è¦ HTTP æœåŠ¡å™¨ host çš„ã€‚

#### åº”ç­”

ä¸€ä¸ªå…¸å‹çš„ `M-SEARCH` æ¶ˆæ¯å¯ä»¥é•¿è¿™æ ·ï¼š

```http
M-SEARCH * HTTP/1.1
MX: 1
ST: upnp:rootdevice
MAN: "ssdp:discover"
User-Agent: Linux/3.0.0 UPnP/1.0 Platinum/1.0.5.13
Connection: close
Host: 239.255.255.250:1900
```

æ—¢ç„¶æˆ‘ä»¬åšçš„æ˜¯ dummy DMRï¼Œå¯ä»¥å·ä¸ªæ‡’ - åªè¦çœ‹åˆ° `M-SEARCH` æ¶ˆæ¯å°±å›åº”ï¼Œè€Œä¸å¿…å¤„ç†å®ƒçš„æœç´¢ç›®æ ‡æ˜¯ä¸æ˜¯æˆ‘ä»¬çš„ DMRï¼Œå› æ­¤æ­¤å¤„ä¸å±•å¼€ã€‚å¯¹ä¸Šè¿°æœç´¢æ¶ˆæ¯çš„å›åº”æ˜¯ï¼š

```http
HTTP/1.1 200 OK
ST: upnp:rootdevice
USN: uuid:04f976f9-14d8-4205-a6c4-950dad87c430::upnp:rootdevice
Location: http://192.168.14.122:2869/upnphost/udhisapi.dll?content=uuid:04f976f9-14d8-4205-a6c4-950dad87c430
Cache-Control: max-age=1800
Server: Microsoft-Windows/10.0 UPnP/1.0 UPnP-Device-Host/1.0
Ext:
Date: Wed, 28 May 2025 03:51:18 GMT
```

### HTTP

å› ä¸º Windows Media Player çš„ç½‘å€è·¯ç”±éš¾ä»¥ç†è§£ï¼Œæ¥ä¸‹æ¥æˆ‘å°†ä½¿ç”¨æˆ‘é‡æ˜ å°„çš„è·¯ç”±è¿›è¡Œè®²è§£ã€‚æœ€å…³é”®çš„ä¸»è¦æœ‰ä»¥ä¸‹ä¸‰ä¸ªè·¯ç”±ï¼š

- `/DeviceSpec`: è®¾å¤‡æè¿°è·¯ç”±
- `/AVTransport`: `AVTransport` æœåŠ¡è·¯ç”±
- `/RenderingControl`: `RenderingControl` æœåŠ¡è·¯ç”±

#### DeviceSpec

è¿™ä¸ªè·¯ç”±åªæ¥å— `GET` æ–¹æ³•ï¼Œè¿”å›è®¾å¤‡æè¿°æ–‡ä»¶ã€‚è®¾å¤‡æè¿°æ–‡ä»¶ç”¨ XML å®šä¹‰ï¼Œä¸»è¦åŒ…å«è®¾å¤‡ç±»å‹ã€åç§°ã€åˆ¶é€ å•†ã€åºåˆ—å·ã€UUID ä»¥åŠåŒ…å«çš„æœåŠ¡ç­‰ä¿¡æ¯ã€‚ä¸‹é¢çš„ä¸¤ä¸ªè·¯ç”±éƒ½æ˜¯ä»è¿™é‡Œå®šä¹‰çš„ã€‚[ç¤ºä¾‹è®¾å¤‡æè¿°æ–‡ä»¶æ¨¡æ¿](https://github.com/PRO-2684/dlna-dmr/blob/c0f8c6f2b8c13c270fa7f12e8199b3a86459df68/src/template/DeviceSpec.tmpl.xml)ã€‚

#### AVTransport

è¿™ä¸ªè·¯ç”±åœ¨ `GET` æ–¹æ³•ä¸‹è¿”å› `AVTransport` æœåŠ¡çš„æœåŠ¡æè¿°æ–‡ä»¶ï¼Œåœ¨ `POST` æ–¹æ³•ä¸‹è°ƒç”¨æ­¤æœåŠ¡çš„æŸä¸ªåŠ¨ä½œã€‚ä¸»è¦åŒ…æ‹¬æŸ¥è¯¢æ›´æ”¹æ’­æ”¾å†…å®¹ã€æ’­æ”¾è¿›åº¦ã€å¾ªç¯æ¨¡å¼ï¼Œå¼€å§‹ã€æš‚åœã€åœæ­¢æ’­æ”¾ç­‰åŠ¨ä½œã€‚[ç¤ºä¾‹ AVTransport æœåŠ¡æè¿°æ–‡ä»¶](https://github.com/PRO-2684/dlna-dmr/blob/c0f8c6f2b8c13c270fa7f12e8199b3a86459df68/src/template/AVTransport.xml)ã€‚ä¸€ä¸ªç¤ºä¾‹ POST è¯·æ±‚ä½“å¦‚ä¸‹ï¼š

```xml
<?xml version="1.0" encoding="UTF-8"?>
<s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
    <s:Body>
        <u:SetAVTransportURI xmlns:u="urn:schemas-upnp-org:service:AVTransport:1">
            <InstanceID>0</InstanceID>
            <CurrentURI>http://example.com/sample.mp4?param1=a&amp;param2=b</CurrentURI>
            <CurrentURIMetaData/>
        </u:SetAVTransportURI>
    </s:Body>
</s:Envelope>
```

å®ƒå°±æ˜¯è°ƒç”¨äº† `AVTransport` çš„ `SetAVTransportURI`ï¼Œå…¶ä¸­å‚æ•° `InstanceID` ä¸º `0`ï¼Œå‚æ•° `CurrentURI` ä¸º `http://example.com/sample.mp4?param1=a&param2=b` (æ³¨æ„è§£ç )ï¼Œå‚æ•° `CurrentURIMetaData` ä¸ºç©ºã€‚æ„æ€å°±æ˜¯è®¾ç½®æ’­æ”¾çš„ç½‘å€ä¸º `http://example.com/sample.mp4?param1=a&param2=b`ã€‚

#### RenderingControl

ä¸ `AVTransport` ç±»ä¼¼ï¼Œè¿™ä¸ªè·¯ç”±åœ¨ `GET` æ–¹æ³•ä¸‹è¿”å› `RenderingControl` æœåŠ¡çš„æœåŠ¡æè¿°æ–‡ä»¶ï¼Œåœ¨ `POST` æ–¹æ³•ä¸‹è°ƒç”¨æ­¤æœåŠ¡çš„æŸä¸ªåŠ¨ä½œã€‚ä¸»è¦åŒ…æ‹¬æŸ¥è¯¢æ›´æ”¹é™éŸ³ã€éŸ³é‡ç­‰åŠ¨ä½œã€‚[ç¤ºä¾‹ RenderingControl æœåŠ¡æè¿°æ–‡ä»¶](https://github.com/PRO-2684/dlna-dmr/blob/c0f8c6f2b8c13c270fa7f12e8199b3a86459df68/src/template/RenderingControl.xml)ã€‚

## ä»£ç å®ç°

### ğŸ Python POC

æœ€åï¼Œå°†ä¸Šè¿°å†…å®¹ç»“åˆèµ·æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ Python åšä¸€ä¸ªæœ€å°çš„ dummy DMRï¼Œç”¨äºéªŒè¯æˆ‘ä»¬çš„çŒœæƒ³ï¼š

```python
import socket
from http.server import BaseHTTPRequestHandler, HTTPServer
import threading
import uuid
from datetime import datetime, timezone

# Configuration - Protocol and Network
IP = socket.gethostbyname(socket.gethostname())
SSDP_PORT = 1900
HTTP_PORT = 8000

# Configuration - Device Information
FRIENDLY_NAME = "Dummy Renderer"
MODEL_NAME = "Dummy Model"
MODEL_DESCRIPTION = "A dummy UPnP renderer for testing purposes"
MODEL_URL = "http://dummy-renderer.com/model"
MANUFACTURER = "Dummy Manufacturer"
MANUFACTURER_URL = "http://dummy-manufacturer.com"
SERIAL_NUMBER = "12345678-1234-5678-1234-567812345678"
UUID = str(uuid.uuid5(uuid.NAMESPACE_URL, 'DummyRenderer'))

# Constants
SSDP_IP = "239.255.255.250"
SSDP_HOST = "239.255.255.250:1900"
SERVER_NAME = "DummyRenderer/1.0 UPnP/1.0 UPnP-Device-Host/1.0"

# XMLs - Get them from https://github.com/PRO-2684/dlna-dmr/blob/c0f8c6f2b8c13c270fa7f12e8199b3a86459df68/src/template/
with open("./xml/DeviceSpec.tmpl.xml", "r") as f:
    DEVICE_SPEC_XML = f.read() \
        .replace("{{friendlyName}}", FRIENDLY_NAME) \
        .replace("{{modelName}}", MODEL_NAME) \
        .replace("{{modelDescription}}", MODEL_DESCRIPTION) \
        .replace("{{modelURL}}", MODEL_URL) \
        .replace("{{manufacturer}}", MANUFACTURER) \
        .replace("{{manufacturerURL}}", MANUFACTURER_URL) \
        .replace("{{serialNumber}}", SERIAL_NUMBER) \
        .replace("{{uuid}}", UUID) \
        .encode('utf-8')
with open("./xml/RenderingControl.xml", "rb") as f:
    RENDERING_CONTROL_XML = f.read()
with open("./xml/AVTransport.xml", "rb") as f:
    AV_TRANSPORT_XML = f.read()

def gmt_time():
    """Return the current time in GMT format."""
    return datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S GMT')

class SSDPServer(threading.Thread):
    def __init__(self):
        super().__init__()
        self.daemon = True
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # Create a UDP socket
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Allow reuse of the address
        self.sock.bind(('', SSDP_PORT)) # Bind to all interfaces on SSDP_PORT
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) # Allow receiving broadcast messages
        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(SSDP_IP) + socket.inet_aton(IP)) # Join the multicast group

    def _notify(self, nt: str, nts: str, usn: str):
        """Send a SSDP notify message with given Notification Type, Notification Sub Type and Unique Service Name.

        Parameters:

        - nt: Notification Type (NT)
        - nts: Notification Sub Type (NTS)
        - usn: Unique Service Name (USN)
        """
        message = (
            "NOTIFY * HTTP/1.1\r\n"
            f"HOST: {SSDP_HOST}\r\n"
            f"NT: {nt}\r\n"
            f"NTS: {nts}\r\n"
            f"USN: {usn}\r\n"
            f"Location: http://{IP}:{HTTP_PORT}/DeviceSpec\r\n"
            "Cache-Control: max-age=1800\r\n"
            f"Server: {SERVER_NAME}\r\n"
            'OPT:"http://schemas.upnp.org/upnp/1/0/"; ns=01\r\n'
            "\r\n"
        )
        self.sock.sendto(message.encode('utf-8'), (SSDP_IP, SSDP_PORT))

    def _notify_service(self, service: str, nts: str):
        """Broadcast a notify message for given `service` with given Notification Sub Type.

        Parameters:

        - service: The UPnP service name (e.g., "RenderingControl", "AVTransport", "ConnectionManager")
        - nts: Notification Sub Type (NTS)
        """
        self._notify(
            nt=f"urn:schemas-upnp-org:service:{service}:1",
            nts=nts,
            usn=f"uuid:{UUID}::urn:schemas-upnp-org:service:{service}:1",
        )

    def _notify_all(self, nts: str):
        """Broadcast multiple relevant notify messages with given Notification Sub Type.

        Parameters:

        - nts: Notification Sub Type (NTS)
        """
        self._notify(
            nt="upnp:rootdevice",
            nts=nts,
            usn=f"uuid:{UUID}::upnp:rootdevice",
        )
        self._notify(
            nt=f"uuid:{UUID}",
            nts=nts,
            usn=f"uuid:{UUID}",
        )
        for service in ["RenderingControl", "AVTransport", "ConnectionManager"]:
            self._notify_service(service, nts=nts)

    def alive(self):
        """Broadcast multiple relevant `ssdp:alive` messages."""
        self._notify_all(nts="ssdp:alive")

    def bye(self):
        """Broadcast multiple relevant `ssdp:byebye` message."""
        self._notify_all(nts="ssdp:byebye")

    def answer(self, ip: str, port: int, message: str):
        """Answer a SSDP message from given IP and port."""
        if message.startswith("M-SEARCH"):
            self._answer_discover(ip, port)
        elif message.startswith("NOTIFY"):
            print(f"Received NOTIFY message from {ip}:{port}:\n{message}")
        else:
            print(f"Unhandled SSDP message: {message}")

    def _answer_discover(self, ip: str, port: int):
        """Answer a `ssdp:discover` request from given IP and port, like:

        ```
        M-SEARCH * HTTP/1.1
        MX: 1
        ST: upnp:rootdevice
        MAN: "ssdp:discover"
        User-Agent: Linux/3.0.0 UPnP/1.0 Platinum/1.0.5.13
        Connection: close
        Host: 239.255.255.250:1900
        ```
        """
        message = (
            "HTTP/1.1 200 OK\r\n"
            f"ST: upnp:rootdevice\r\n"
            f"USN: uuid:{UUID}::upnp:rootdevice\r\n"
            f"Location: http://{IP}:{HTTP_PORT}/DeviceSpec\r\n"
            'OPT:"http://schemas.upnp.org/upnp/1/0/"; ns=01\r\n'
            "Cache-Control: max-age=900\r\n"
            f"Server: {SERVER_NAME}\r\n"
            "EXT:\r\n"
            f"Date: {gmt_time()}\r\n"
            "\r\n"
        )
        self.sock.sendto(message.encode('utf-8'), (ip, port))

    def run(self):
        print(f"SSDP server running on {IP}:{SSDP_PORT}")
        while True:
            try:
                data, addr = self.sock.recvfrom(4096)
                message = data.decode('utf-8')
                print(f"[SSDP] Received message from {addr[0]}:{addr[1]}:\n{message}")
                self.answer(addr[0], addr[1], message)
            except Exception as e:
                print(f"Error: {e}")

class HTTPRequestHandler(BaseHTTPRequestHandler):
    """HTTP request handler for the dummy UPnP renderer. Endpoints:

    - /RenderingControl
    - /DeviceSpec
    - /AVTransport
    - /Ignore
    """
    def do_GET(self):
        print(f"GET request from {self.client_address[0]}:{self.client_address[1]} to {self.path}")
        print(f"Headers: {self.headers}")
        if self.path == "/DeviceSpec":
            self.send_response(200)
            self.send_header("Content-Type", "text/xml; charset=utf-8")
            self.end_headers()
            self.wfile.write(DEVICE_SPEC_XML)
        elif self.path == "/RenderingControl":
            self.send_response(200)
            self.send_header("Content-Type", "text/xml; charset=utf-8")
            self.end_headers()
            self.wfile.write(RENDERING_CONTROL_XML)
        elif self.path == "/AVTransport":
            self.send_response(200)
            self.send_header("Content-Type", "text/xml; charset=utf-8")
            self.end_headers()
            self.wfile.write(AV_TRANSPORT_XML)
        elif self.path == "/Ignore":
            self.send_response(204)  # No Content
            self.end_headers()
        else:
            self.send_error(404, "Not Found")

    def do_POST(self):
        # Log the request details
        print(f"POST request from {self.client_address[0]}:{self.client_address[1]} to {self.path}")
        print(f"Headers: {self.headers}")
        print(f"Body: {self.rfile.read(int(self.headers.get('Content-Length', 0))).decode('utf-8')}")
        if self.path == "/DeviceSpec":
            # Errors for now
            self.send_error(718, "Invalid InstanceID") # UPnP error code for "Invalid InstanceID"
            # See 5.4.32 Common Error Codes of AVTransport-v3-Service
        elif self.path == "/RenderingControl":
            self.send_error(718, "Invalid InstanceID")
        elif self.path == "/AVTransport":
            self.send_error(718, "Invalid InstanceID")
        elif self.path == "/Ignore":
            self.send_error(718, "Invalid InstanceID")
        else:
            self.send_error(404, "Not Found")

if __name__ == "__main__":
    # Start SSDP server
    ssdp_server = SSDPServer()
    ssdp_server.start()
    ssdp_server.alive()

    # Start HTTP server
    httpd = HTTPServer((IP, HTTP_PORT), HTTPRequestHandler)
    print(f"HTTP server running on {IP}:{HTTP_PORT}")

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Shutting down the server...")
        ssdp_server.bye()
        httpd.server_close()
        print("Server stopped.")
```

å…¶ä¸­æ‰€éœ€çš„ XML æ¨¡æ¿æ–‡ä»¶å¯ä»¥ä» [æ­¤å¤„](https://github.com/PRO-2684/dlna-dmr/blob/c0f8c6f2b8c13c270fa7f12e8199b3a86459df68/src/template/) ä¸‹è½½ã€‚å®ƒæ‰“å°äº†æ‰€æœ‰ `GET` å’Œ `POST` è¯·æ±‚ï¼Œä½†æ˜¯ä»ç„¶éœ€è¦è‡ªå·±åœ¨ä¸€å¤§å †æ—¥å¿—å†…æ‰¾åˆ°ç½‘å€ç„¶åè‡ªè¡Œè§£ç ã€‚æ— è®ºå¦‚ä½•ï¼Œå¯¹äºå±€åŸŸç½‘å†…çš„å…¶å®ƒè®¾å¤‡ï¼Œå®ƒç¡®å®æ˜¯ä¸€ä¸ªè´§çœŸä»·å®çš„ DMRã€‚

### ğŸ¦€ Rust

æœ€ç»ˆæˆ‘å°†è¿™ä»½ä»£ç è¿ç§»åˆ°äº† Rustï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```rust
// ssdp.rs
#[derive(Debug)]
pub struct SSDPServer {
    socket: UdpSocket,
    address: SocketAddrV4,
    uuid: String,
    http_port: u16,
}

impl SSDPServer {
    /// The multicast address used for SSDP discovery.
    const SSDP_MULTICAST_ADDR: SocketAddrV4 =
        SocketAddrV4::new(Ipv4Addr::new(239, 255, 255, 250), 1900);
    /// The SSDP server's name.
    const SSDP_SERVER_NAME: &'static str = "CustomSSDP/1.0";
    /// Interval for sending keep-alive messages.
    const KEEP_ALIVE_INTERVAL: Duration = Duration::from_secs(60);

    /// Creates a new SSDP server bound to the specified address with the given UUID and HTTP port.
    pub async fn new(address: SocketAddrV4, uuid: String, http_port: u16) -> Result<Self> {
        let socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;
        socket.set_nonblocking(true)?;
        socket.set_reuse_address(true)?;
        socket.bind(&SockAddr::from(SocketAddrV4::new(
            Ipv4Addr::UNSPECIFIED,
            address.port(),
        )))?;
        // Set the socket to allow broadcast.
        socket.set_broadcast(true)?;
        // Join the SSDP multicast group.
        socket.join_multicast_v4(
            Self::SSDP_MULTICAST_ADDR.ip(), // Multicast address
            address.ip(),                   // Use the unspecified address for the local interface
        )?;
        // Convert the socket to a Tokio UdpSocket.
        let socket = UdpSocket::from_std(socket.into())?;

        Ok(Self {
            socket,
            address,
            uuid,
            http_port,
        })
    }

    /// Send a SSDP notify message with given Notification Type, Notification Sub Type and Unique Service Name.
    async fn notify(&self, nt: &str, nts: &str, usn: &str) -> Result<()> {
        let message = format!(
            "NOTIFY * HTTP/1.1\r\n\
             HOST: {}\r\n\
             NT: {}\r\n\
             NTS: {}\r\n\
             USN: {}\r\n\
             LOCATION: http://{}/description.xml\r\n\
             CACHE-CONTROL: max-age=1800\r\n\
             SERVER: {}\r\n\
             \r\n",
            Self::SSDP_MULTICAST_ADDR,
            nt,
            nts,
            usn,
            self.address,
            Self::SSDP_SERVER_NAME
        );
        self.socket
            .send_to(message.as_bytes(), &Self::SSDP_MULTICAST_ADDR)
            .await?;
        Ok(())
    }

    /// Broadcast a notify message for given `service` with given Notification Sub Type.
    async fn notify_service(&self, service: &str, nts: &str) -> Result<()> {
        self.notify(
            &format!("urn:schemas-upnp-org:service:{service}:1"),
            nts,
            &format!(
                "uuid:{uuid}::urn:schemas-upnp-org:service:{service}:1",
                uuid = self.uuid
            ),
        )
        .await
    }

    /// Broadcast multiple relevant notify messages with given Notification Sub Type.
    async fn notify_all(&self, nts: &str) -> Result<()> {
        let uuid_with_prefix = format!("uuid:{}", self.uuid);

        self.notify(
            "upnp:rootdevice",
            nts,
            &format!("{uuid_with_prefix}::upnp:rootdevice"),
        )
        .await?;
        self.notify(&uuid_with_prefix, nts, &uuid_with_prefix)
            .await?;
        for service in ["RenderingControl", "AVTransport", "ConnectionManager"] {
            self.notify_service(service, nts).await?;
        }

        Ok(())
    }

    /// Broadcast multiple relevant `ssdp:alive` messages.
    async fn alive(&self) -> Result<()> {
        self.notify_all("ssdp:alive").await
    }

    /// Broadcast multiple relevant `ssdp:alive` messages periodically. (Keep-alive / Heartbeat)
    pub async fn keep_alive(&self) {
        info!("Starting SSDP keep-alive thread");
        loop {
            if let Err(e) = self.alive().await {
                error!("Failed to send SSDP alive message: {e}");
            } else {
                trace!("SSDP alive message sent");
            }
            sleep(Self::KEEP_ALIVE_INTERVAL).await;
        }
    }

    /// Broadcast multiple relevant `ssdp:byebye` messages.
    async fn byebye(&self) -> Result<()> {
        self.notify_all("ssdp:byebye").await
    }

    /// Answer a SSDP message from given address.
    async fn answer(&self, address: SocketAddrV4, message: &str) -> Result<()> {
        if message.starts_with("M-SEARCH") {
            self.answer_search(address, message).await
        } else if message.starts_with("NOTIFY") {
            Ok(())
        } else {
            Err(Error::new(
                ErrorKind::InvalidData,
                format!("Received unknown SSDP message: {message}"),
            ))
        }
    }

    /// Answer a M-SEARCH request.
    async fn answer_search(&self, address: SocketAddrV4, _message: &str) -> Result<()> {
        let response = format!(
            "HTTP/1.1 200 OK\r\n\
             ST: upnp:rootdevice\r\n\
             USN: uuid:{}::upnp:rootdevice\r\n\
             Location: http://{}:{}/DeviceSpec\r\n\
             OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n\
             Cache-Control: max-age=900\r\n\
             Server: {}\r\n\
             EXT:\r\n\
             Date: {}\r\n\
            \r\n",
            self.uuid,
            self.address.ip(),
            self.http_port,
            Self::SSDP_SERVER_NAME,
            chrono::Utc::now().format("%a, %d %b %Y %H:%M:%S GMT")
        );
        trace!("Sending SSDP response to {address}: {response}");
        self.socket.send_to(response.as_bytes(), address).await?;

        Ok(())
    }

    /// Starts the SSDP server.
    pub async fn run(&self) {
        info!("SSDP server running on {}", self.address);

        let mut buf = [0u8; 4096];
        loop {
            match self.socket.recv_from(&mut buf).await {
                Ok((size, addr)) => {
                    let message = String::from_utf8_lossy(&buf[..size]);
                    let SocketAddr::V4(ipv4) = addr else {
                        error!("Received non-IPv4 address: {addr:?}");
                        continue;
                    };
                    trace!("Received SSDP message from {ipv4}: {message}");
                    if let Err(e) = self.answer(ipv4, &message).await {
                        error!("Error answering SSDP message: {e}");
                    }
                }
                Err(e) if e.kind() == ErrorKind::WouldBlock => {} // Non-blocking mode, just do nothing.
                Err(e) => {
                    error!("Error receiving SSDP message: {e}");
                }
            }
        }
    }

    /// Stops the SSDP server.
    pub async fn stop(&self) {
        if let Err(e) = self.byebye().await {
            error!("Failed to send SSDP byebye message: {e}");
        } else {
            info!("SSDP server stopped");
        }
    }
}
// http.rs
pub trait HTTPServer: Sync {
    /// Create and run a HTTP server with the given options.
    fn run_http(&'static self, options: Arc<DMROptions>) -> impl Future<Output = IoResult<()>> + Send {async {
        let ip = options.ip;
        let http_port = options.http_port;
        let listener = tokio::net::TcpListener::bind(SocketAddrV4::new(ip, http_port)).await?;
        info!("HTTP server listening on {ip}:{http_port}");

        let app = Router::new()
            .route(
                "/DeviceSpec",
                get(async || Self::get_device_spec(options).await).post(Self::post_device_spec),
            )
            .route(
                "/RenderingControl",
                get(Self::get_rendering_control).post(async |s: String| {
                    self.post_rendering_control(RenderingControl::from_str(&s))
                        .await
                }),
            )
            .route(
                "/AVTransport",
                get(Self::get_av_transport).post(async |s: String| {
                    self.post_av_transport(AVTransport::from_str(&s)).await
                }),
            )
            .route(
                "/Ignore",
                get(Self::get_ignore).post(async || self.post_ignore().await),
            );

        axum::serve(listener, app).await
    } }

    // POST Request handlers for specific endpoints.

    /// Handles POST requests for `/DeviceSpec`.
    fn post_device_spec() -> impl Future<Output = impl IntoResponse> + Send {
        async { StatusCode::METHOD_NOT_ALLOWED }
    }

    /// Handles POST requests for `/RenderingControl`.
    fn post_rendering_control(
        &self,
        rendering_control: Result<RenderingControl, DeError>,
    ) -> impl Future<Output = impl IntoResponse> + Send {
        async { StatusCode::METHOD_NOT_ALLOWED }
    }

    /// Handles POST requests for `/AVTransport`.
    fn post_av_transport(
        &self,
        av_transport: Result<AVTransport, DeError>,
    ) -> impl Future<Output = impl IntoResponse> + Send {
        async { StatusCode::METHOD_NOT_ALLOWED }
    }

    /// Handles POST requests for `/Ignore`.
    fn post_ignore(&self) -> impl Future<Output = impl IntoResponse> + Send {
        async { StatusCode::NO_CONTENT }
    }

    // GET Request handlers for specific endpoints.

    /// Handles GET requests for `/DeviceSpec`.
    fn get_device_spec(options: Arc<DMROptions>) -> impl Future<Output = impl IntoResponse> + Send {
        async move {
            /// Escapes given field under `options`.
            macro_rules! e {
                ($i:ident) => {
                    escape(&options.$i)
                };
            }
            let xml = format!(
                include_str!("./template/DeviceSpec.tmpl.xml"),
                friendlyName = e!(friendly_name),
                modelName = e!(model_name),
                modelDescription = e!(model_description),
                modelURL = e!(model_url),
                manufacturer = e!(manufacturer),
                manufacturerURL = e!(manufacturer_url),
                serialNumber = e!(serial_number),
                uuid = e!(uuid),
            );
            (
                StatusCode::OK,
                [("Content-Type", r#"text/xml; charset="utf-8""#)],
                xml,
            )
        }
    }

    /// Handles GET requests for `/RenderingControl`.
    fn get_rendering_control() -> impl Future<Output = impl IntoResponse> + Send {
        async {
            (
                StatusCode::OK,
                [("Content-Type", r#"text/xml; charset="utf-8""#)],
                include_str!("./template/RenderingControl.xml"),
            )
        }
    }

    /// Handles GET requests for `/AVTransport`.
    fn get_av_transport() -> impl Future<Output = impl IntoResponse> + Send {
        async {
            (
                StatusCode::OK,
                [("Content-Type", r#"text/xml; charset="utf-8""#)],
                include_str!("./template/AVTransport.xml"),
            )
        }
    }

    /// Handles GET requests for `/Ignore`.
    fn get_ignore() -> impl Future<Output = impl IntoResponse> + Send {
        async { StatusCode::NO_CONTENT }
    }
}
```

ç¤ºä¾‹æ—¥å¿—è¾“å‡ºå¦‚ä¸‹ï¼š

```shell
$ dlna-dmr
[2025-05-30T14:49:48Z INFO  dlna_dmr] DMR started
[2025-05-30T14:49:48Z INFO  dlna_dmr::ssdp] SSDP server running on 172.31.117.144:1900
[2025-05-30T14:49:48Z INFO  dlna_dmr::http] HTTP server listening on 172.31.117.144:8080
[2025-05-30T14:50:11Z INFO  dlna_dmr::http] RenderingControl::SetMute channel: Master, desired_mute: false
[2025-05-30T14:50:38Z INFO  dlna_dmr::http] AVTransport::SetAvTransportUri current_uri: http://example.com/sample.mp4?param1=a&param2=b
^C
[2025-05-30T14:50:46Z INFO  dlna_dmr::http] HTTP server stopped
[2025-05-30T14:50:46Z INFO  dlna_dmr::ssdp] SSDP server stopped
[2025-05-30T14:50:46Z INFO  dlna_dmr] DMR stopped
```

è¿™å°±å·²ç»å¾ˆæ˜æ™°äº†ã€‚ä¸ºäº†å‡å°‘è¾“å‡ºï¼Œæˆ‘åªè¾“å‡ºäº†è®¾ç½®çŠ¶æ€çš„æŒ‡ä»¤ï¼Œè€Œå¿½ç•¥æŸ¥è¯¢çŠ¶æ€çš„æŒ‡ä»¤ã€‚ä»£ç ä»“åº“å’Œé¢„ç¼–è¯‘çš„å¯æ‰§è¡Œæ–‡ä»¶å°±åœ¨ [PRO-2684/dlna-dmr](https://github.com/PRO-2684/dlna-dmr/)ï¼Œæ¬¢è¿å¤§å®¶å°è¯•ã€‚

## å‚è€ƒèµ„æ–™

- æŠ“åŒ…ç»“æœï¼ˆæ–‡æ¡£çœ‹å¾ˆä¹…ç†è§£ä¸èƒ½ï¼Œæœç„¶è¿˜æ˜¯å¾—å®è·µå‡ºçœŸçŸ¥ï¼‰
- UPnP çš„æ–‡æ¡£ï¼ˆå’ŒæŠ“åŒ…ç»“æœäº’ä¸ºè¡¥å……ï¼Œä¸æ˜ç™½çš„å­—æ®µå¯ä»¥æŸ¥æ–‡æ¡£ï¼‰
    - [MediaRenderer-v1-Device](https://upnp.org/specs/av/UPnP-av-MediaRenderer-v1-Device.pdf)
    - [AVTransport-v1-Service](https://upnp.org/specs/av/UPnP-av-AVTransport-v1-Service.pdf)
    - [RenderingControl-v1-Service](https://upnp.org/specs/av/UPnP-av-RenderingControl-v1-Service.pdf)
